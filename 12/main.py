#!/usr/bin/env python3

import sys
from collections import defaultdict, deque
from functools import lru_cache


@lru_cache
def is_lower(string):
    return string == string.lower()


def is_valid_part_1(node, existing):
    return True if not is_lower(node) or node not in existing else False


def is_valid_part_2(node, existing):
    if not is_lower(node) or node not in existing:
        return True
    else:
        # False if any small caves that have been visited twice
        small_caves = [cave for cave in existing if is_lower(cave)]
        return len(small_caves) == len(set(small_caves))


class CaveSystem:
    def __init__(self, pairs):
        self.adjacent = defaultdict(set)
        for a, b in pairs:
            if a != "end" and b != "start":
                self.adjacent[a].add(b)
            if a != "start" and b != "end":
                self.adjacent[b].add(a)

        self.n_paths = 0

    def visit(self, node, valid, path):
        """
        Recursively visit child nodes.

        node: visit this node, adding it to the current path
        valid: callable testing if it's valid to visit a node given the existing path
        path: history of nodes that have been visited
        """
        path.append(node)
        if node == "end":
            self.n_paths += 1
        else:
            for child in self.adjacent[node]:
                if valid(child, path):
                    self.visit(child, valid, path)
        path.pop()


def find_paths(pairs, child_valid):
    cs = CaveSystem(pairs)
    cs.visit("start", child_valid, deque())
    return cs.n_paths


if __name__ == "__main__":
    pairs = [line.strip().split("-") for line in sys.stdin]

    print(find_paths(pairs, is_valid_part_1))
    print(find_paths(pairs, is_valid_part_2))
